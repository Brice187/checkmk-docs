include::global_attr.adoc[]
= Users, roles and permissions
:revdate: 2016-10-20
:title: Authorization and user configuration
:description: Each monitored object has a responsible person. Here you can learn what roles or contact groups are, and everything else important to user management.

{related-start}
link:wato.html[Configuring {CMK}]
link:wato_rules.html[Host and service parameters]
link:ldap.html[User Management with LDAP/Active Directory]
{related-end}

== Introduction

In this article we will present information on all aspects of user management and
permissions in {CMK}. Before we go into the details, however,
we’ll first need to explain a few terms.

In {CMK} a *[.guihint]#User*# is one with access to the
link:user_interface.html[User interface]. They have one or more *[.guihint]#Roles#*.
From these roles [.guihint]#*Permissions*# are derived.

Once a user is made responsible for specific hosts and services,
they are identified as a *[.guihint]#Contact#*.
A contact normally sees only their own hosts and services in the user interface,
and receives link:notifications.html[notifications] regarding possible problems.

There are also users who are not contacts. An example would be `cmkadmin`,
which is generated automatically when an instance is created.
This can in fact see all hosts and services, but only because its `admin` role
includes the [.guihint]#See all hosts and services# permission -- not because it is a contact for all.

If a contact has only been created for the purpose of link:notifications.html[notifications]
(e.g., for forwarding notifications to a ticket system), it can be sensible to set it up
so that a login is not possible from the interface.

A Contact is always a member of one or more *[.guihint]#Contact Groups#*.
The purpose of these groups is the allocation of contacts to hosts and services.
For example: the contact `hhirsch` could be in the `linux` contact group,
and this can in turn be allocated to all Linux hosts via link:wato_rules.html[rules].
A direct allocation of contacts to hosts or services is not possible, and in practice
would create difficulties (e.g., when ‘retiring’ a user).

To summarise:

* *Users* can utilise the user interface.
* *Contacts* are users who are responsible for specific hosts and services.
* *Contact Groups* define *what* someone is *responsible* for.
* *Roles* define a user’s *Permissions*.

[#user_config]
== User management with WATO

=== Overview

User management can be found in the [.guihint]#Users# link:wato.html[WATO] module icon:icon_users[].
In a newly-created instance this page will appear as below:

[{image-border}]
image::wato_user_users.png[]

Here `cmkadmin` can be seen -- the only user which is automatically
generated when a new instance is created. In {CMK}-Appliance this user can have
a different name because you can specify the name and password yourself.

This very first user has the following characteristics:

* It has the [.guihint]#Administrator# (`admin`) role and therefore has all permissions!
* It is a contact for nothing and receives no notifications.
* It can however view everything (due to its `admin` role).
* The default password should be replaced by a new one as soon as possible!

Incidentally, on the User’s page title line you can always see who you are logged-in as -- your logon-ID and (role):

[{image-border}]
image::wato_user_title.png[]

The mask for creating a new user with icon:button_new_user[], or for
editing an existing user with icon:icon_edit[] consists of five sections.

The first subsection menu is for the identity:

=== Identity

image::wato_user_identity.png[]

As always in {CMK}, the ID of a dataset -- (here [.guihint]#Username#) -- cannot be
changed retrospectively.
This will be used for the registration, and also as an internal key in all files
and file structures.

The email address is optional and only required if the user is to be a contact who should
receive link:notifications.html[notifications] by email (link:install_packages.html#smtpconfig[SMTP configuration] necessary).
The [.guihint]#Pager address# field is analogous and is intended for notifications
per SMS or similar systems. If you are coding your own notification scripts,
the values in these fields can be accessed and used as required.

Via [.guihint]#Authorized sites# you can optionally restrict access to specific existing sites. This is useful especially in very large environments, such as a
distributed monitoring with hundreds of sites: If a user only needs a portion of these sites for his hosts, the GUI will contact only the authorized sites to build views. This in turn greatly improves performance.

=== Security

image::wato_user_security.png[]

The second subsection menu is for the login and permissions.
The [.guihint]#Automation secret for machine accounts# option is intended for accounts that
are controlled by scripts which access {CMK} per HTTP, and which are authenticated via the URL.
Later we will show how this works link:wato_user.html#automation[see below].

At least one role must be selected. You can theoretically give multiple roles to a user -- in
which case the user will receive the authorisations from all of these roles.
With the three predefined roles (link:wato_user.html#roles[see below]) this would make little sense however.

If you *lock* a user with the [.guihint]#disable the login to this account# option,
it will appear with the icon:icon_user_locked[] symbol in the table.
It will not be able to login but will nonetheless remain in the system.
If it is a contact its notifications will not be affected and it will still receive emails, etc.
If the user was logged in at the time of the locking action, it will be automatically logged out.

=== Contact groups

image::wato_user_contact_groups.png[]

As soon as a user is allocated to one or more contact groups it will become a contact.
For a new instance the contact group [.guihint]#Everything# is automatically generated,
which will always include all hosts and all services.
A user in this group is automatically responsible for _all_ hosts and services.

=== Notifications

image::wato_user_notifications_fallback.png[]

In the [.guihint]#Notifications# box, you can use the [.guihint]#Receive fallback notifications#
option to specify that this contact should receive alerts for events when
link:notifications.html[no notification rule applies.]

[#user_config_personal]
=== Personal settings

image::wato_user_personal_settings.png[]

All settings in the last subsection menu link:wato_user.html#personal_settings[can also be changed by the user themselves]
using icon:button_sidebar_settings[] -- (except when in the `guest` role).
Apart from the choice of language, the interface contains some rarely-required settings -- as always
details for these can be found in the online help icon:icon_help[].

[#contact_groups]
== Contact groups

=== Creating and editing contact groups

Contact groups are the link between hosts and services on one side and contacts on the other.
Every contact group represents a responsibility for a specific area in your IT landscape.
For example, the `SAP` contact group could include all personnel who manage a SAP system,
and the group allocated to all hosts and services providing service in this area.

Contact groups are administered with the icon:icon_contactgroups[] [.guihint]#Contact Groups# WATO module.
The following screenshot shows this module with four defined contact groups:

[{image-border}]
image::wato_user_contact_groups_list.png[]

The creation of a new group is a simple matter. As always, the ID is fixed, and the alias is
a display name that can be changed at any later time:

image::wato_user_contact_groups_new.png[]

The new contact group is at first empty in two respects: it contains neither contacts nor hosts and services.
The allocation of contact groups to contacts is achieved with the user profile,
as we have already seen in user editing. The allocation of hosts and services is performed as follows:

=== Allocating hosts to a contact group

There are two methods for adding hosts to contact groups:
via link:wato_hosts.html#folder[Folder] and via link:wato_rules.html[Rules].
Both methods can also be used in combination.
In this case the host is allocated the sum of the respective contact groups.

==== Allocation via folders

The attributes of a folder are accessed using the icon:button_folder_properties[] button when in the folder.
Here you will find the [.guihint]#Permissions# option.
Activate this check box to access the contact group selection:

image::wato_user_contact_groups_folder.png[]

The actual purpose of this option is to set permissions for administering hosts in WATO -- which
will be covered in detail link:wato_user.html#folder_permissions[below].
When assigning permissions for specific contact groups, at the same time
you can enter these as contact groups for the hosts in monitoring.
You can also decide whether these should be applicable to hosts in subfolders,
and if the host’s services should also _explicitly_ receive these groups.
Services without an explicit allocation in fact inherit *all* of a host’s groups,
including those allocated via rules.

Attention: The link:wato_hosts.html#inheritance[Inheritance] of these [.guihint]#Permissions#-Attributes
via the folder is overridden by this procedure.
This allows you to allocate other contact groups to subfolders.
The allocations are thus cumulative through all parent folders if in these
the [.guihint]#Add these groups as contacts in all subfolders# option is active.

Incidentally, the contact group options may also be found in a simplified form directly
in a host’s details. Hence there you can also allocate contact groups to individual hosts.
As this can quickly become complex however, it should only be used in exceptional cases,
and if really necessary it would probably be preferable to work with rules.

==== Allocation via rules

The second method -- allocating contact groups via link:wato_rules.html[rules] -- is
somewhat more involved, but is considerably more flexible however.
This is also very useful if your folder structure has not been built following an organised
plan, so there is therefore no clear way to simply allocate the folders to contact groups.


The rule set required for this -- [.guihint]#Assignment of hosts to contact groups#  can be accessed
quickly via the contact group’s WATO module and using the icon:button_rules[] button.
In this rule set you will find a predefined rule which is generated when an
instance is created, and which assigns all of the hosts to the [.guihint]#Everything# contact group.

[{image-border}]
image::wato_user_contact_groups_rules_list.png[]


Please note that this rule set is defined so that *all* relevant rules will be evaluated,
and not just the first one!
It can in fact be useful to have a host belonging to multiple contact groups,
and in such a cases each assignment will require its own rule.

image::wato_user_contact_groups_rules_new.png[]

=== Assigning services to contact groups

It is not always a matter of course to have a service in the same contact group as its host.
Therefore, using the [.guihint]#Assignment of services to contact groups# rule set you can assign
services to contact groups -- independently of the host’s groups.
The following rules apply:

* If *no* contact group is assigned to a service, it will automatically receive *the same contact groups as its host*.
* When *at least one* contact group is explicitly assigned to a service, the service will *no longer* inherit its host’s contact groups.

In a simple environment it is sufficient to just allocate contact groups to the hosts.
Once more differentiation is required rules for the services can also be defined.

==== Controlling the allocation

In details for a host or service, located in the Status Overview, you can verify whether all
rules and folders have been correctly configured. Here you can find the [.guihint]#Contact groups#
and [.guihint]#Contacts# entries which list the allocations in effect for the object.

[{image-border}]
image::wato_user_contact_groups_host_details.png[]

[#visibility]
== Visibility of hosts and services

=== Overview

The fact that a normal user -- (the `‘user’` role) -- only sees the objects for which
they are a contact becomes more important as monitoring environments get larger.
This not only simplifies the overview, but also precludes users from interfering where they have no business being.

As the administrator -- (the `‘admin’` role) -- you can of course see everything.
This is controlled by the [.guihint]#See all host and services# permission.
In your icon:button_sidebar_settings[]
link:wato_user.html#personal_settings[personal settings]
you will find the [.guihint]#Only show hosts and services the user is a contact for# check box.
With this you can optionally give up the ‘See all’ permission and thereafter see
only the hosts and services for which you are a contact.
This option is intended for dual roles -- for someone who is simultaneously both
the administrator and a normal user of the monitoring.

The `‘guest’` role is predefined so that your users can also see everything.
An intervention or personal settings are deactivated here.

For normal users the visibility in the complete status overview is constructed so
that in the system it appears as if those hosts and services for which one
is not a contact simply do not exist.

Among others, the following elements influence the visibility:

* All tabular host and service link:views.html[Views]
* The [.guihint]#Tactical Overview#
* link:dashboards.html[Dashboards] including the ‘Globes’.
* link:reporting.html[Reporting] created by the user

=== Visibility of services

As we showed earlier it is possible that one can be a contact for a host,
but not for all of its services. You will nonetheless be able to see all
of the host’s services in the GUI.

This exception is predefined in this way because it is generally so useful.
In practice, for example, this means that the colleague who is responsible for
the host itself can also see such services (hardware, operating systems, etc.)
that actually have nothing to do with the host.
They will receive no notifications from these however!

If you don’t like this you can change it. The icon:icon_configuration[] global
option for this is [.guihint]#Monitoring Core > Authorization settings#.
If here you change [.guihint]#Hosts# to [.guihint]#Strict - Must be explicit contact of a service#
users will only be able to see services if they are directly assigned as
contacts for the service.

All of this actually has *nothing* to do with a service inheriting its
host’s contact groups in the case of it not having any groups of its own defined.
You _would_ then _be a contact_ for the service -- and receive its notifications.

image::wato_user_authorization_settings.png[]

=== Host and service groups

The second setting in this option concerns host and service groups.
You can normally always see a group if you can see at least one of the group’s
elements -- the group will however _appear_ to contain _only_ those elements that are visible to you.

Switching to [.guihint]#Strict - must be contact of all members# hides all groups for which
you are *not* a contact for at least one host or service in the group.

Please note that both of these settings for visibility
have _no influence_ on link:notifications.html[notifications].

== Notifications

Contact assignments also have an influence on link:notifications.html[notifications].
By default {CMK} notifies all contacts of an affected host or service when problems occur.
This is handled by a notifications rule which is automatically created for a new instance.
This is a very sensible procedure.

Nonetheless, you can customise the rule or supplement it with additional rules if desired,
so that in an extreme case a notification can be triggered quite independently
of contact groups.
A common situation is when there are specific notifications that a user _does not_ want
to receive, or vice versa, a user _does_ want to be informed of problems with certain hosts or services,
even if they are not responsible for those services (and consequently is not a contact).

Details can be found in the link:notifications.html[Article on notifications].

[#roles]
== Roles and permissions

=== Predefined roles

{CMK} always assigns permissions to users using rules -- never directly.
A role is nothing more than a list of permissions.
It is important to understand that roles define the level of permissions and not an actual
connection to any hosts or services. Contact groups exist for this purpose.

{CMK} is provided with the following three predefined roles -- which are never deleted,
but which may be customised as required:
[cols="10,~,~"]
|===
|Role |Permissions |Function 

|admin |All permissions -- notably the authority to change permissions. |The {CMK} Administrator, responsible for managing the monitoring system itself.
|user |May only view its own hosts and services, may only make changes to shared folders in WATO for which it has been authorised, and in general is not permitted to do anything that affects other users. |The normal {CMK} monitoring user who reacts to notifications.
|guest |May see everything but change nothing. |Intended ‘just for looking’ -- whereby all guests share a common account. Also useful for public status screens that hang on a wall.
|===


Roles are managed in the WATO icon:icon_roles[] [.guihint]#Roles & Permissions# module:

[{image-border}]
image::wato_user_roles_list.png[]

Incidentally -- when a new {CMK} instance is created only a single user with the
`admin` role will be generated (`cmkadmin`).
The other two roles will not be used initially.
Should you require a guest user you will have to create it yourself.

=== Adapting existing rules

As usual, the editing mode for a rule is accessed via the icon:icon_edit[] symbol:

The functions of the numerous permissions, here in excerpts, can be found
in the icon:icon_help[] online help.

What is special here -- for every permission there are three possible selections:
_yes_, _no_ and _default (yes)_, or respectively _default(no)_.
All values are initially set to _default_. For the permissions themselves, at first it
makes no difference whether you set them to _yes_ or _default (yes)_.
A new version of {CMK} can alter these default values however (this occurs very rarely).
Explicitly made settings will not be affected by such a change.

Additionally, with this principle you can very quickly identify where a {CMK} varies from standard.

[{image-border}]
image::wato_user_roles_permissions.png[]

=== Defining your own roles

It might come as a surprise that there is no button for creating a new role.
There is a purpose behind this! New roles are derived from existing roles using
the icon:button_clone[] [.guihint]#Clone# button. The new role is not simply a copy,
but retains a connection to the source role (_Based on role_):

image::wato_user_roles_new_role.png[]

This connection has an important function, one with which all of the cloned role's
permissions that have _not_ been explicitly set -- i.e. those that remain set
to [.guihint]#default# -- will be inherited from the original role.
Subsequent changes to the source role will then be passed on. This is very practical
when one considers how many permissions are available. With simple copies it would be
easy to lose the overview -- which is what actually makes your self-defined roles so special.

This derivation solves another problem: since we are actively developing {CMK} new
permissions are added from time to time. At these times we decide in which of the three
roles -- `admin`, `user` and `guest` -- the new permission should be included.
Because your own roles have been derived from one of these three, the new permission will be
automatically preset to a sensible value. It would be simply very impractical, for example,
if you defined your own `user` role in which new permissions were always missing.
You would then be in the situation where for every new feature your role would have to
be adapted in order for your users to be able to use it.

=== Comparing roles with the matrix view

The icon:button_role_matrix[] button helps if you wish to compare the permissions in the individual roles.
This generates the display below, in which not only the individual roles’ permissions can be
compared, but in which you can also see the positions in which explicit permissions have been set
(icon:icon_perm_yes[] Symbol), or respectively, removed (icon:icon_perm_no[] Symbol).

[{image-border}]
image::wato_user_roles_matrix.png[]

[#personal_settings]
== Personal settings

A small number of the user settings can be self-managed by every user.
This is found at the foot of the side bar at the icon:button_sidebar_settings[] button.
This opens the below menu:

image::wato_user_profile_personal_settings.png[]

The most important function here is changing the *password*.
The user must enter both the existing and the new password. As always, a description of the other
setting options can be found in the icon:icon_help[] online help.

In a link:distributed_monitoring.html[distributed monitoring], following each change the new
settings will be immediately passed on to all slave monitoring instances.
Only in this way can it be ensured that the new password will immediately function
everywhere -- meaning it will not be dependent on the next activation of changes.
This however only works for sites that are accessible to the network at this point of time.
All other sites will receive the updates with their next successful [.guihint]#Activate changes#.

[#automation]
== Automation user (for Webservices)

When connecting {CMK} to other systems it is often desired that specific tasks normally
performed using the GUI be automated. Some examples of these are:

* Setting and removing link:monitoring_basics.html#downtimes[downtimes] with scripts
* Managing hosts in WATO with the link:web_api.html[Web-API]
* Retrieving data from link:views.html[views] as CSV or JSON files for further processing
* Retrieving the current status of link:bi.html[BI-Aggregates], in order to create services from them

In this situation an external software must be able to open specific
{CMK}-Overview URLs automatically.
And naturally, here the question is how the user login is to be performed.
The usual method using the login mask is cumbersome, requiring the opening of a number
of URLs in sequence and the saving of a cookie.

To simplify this procedure {CMK} offers the concept of the _Automation user_.
These users are intended exclusively for remote control and don’t permit normal GUI logins.
Authorisation is achieved using specific variables in the URL.

An automation user is created like a normal user, but instead of a password it
receives an _Automation secret_ -- which can be generated automatically with the
icon:icon_random[] randomising die:

image::wato_user_automation_user.png[]

Just like a normal user, an automation user has a role and can also be a contact.
With these you can thus restrict its permissions and visibility of hosts and services as required.

When opening websites automatically, you enter the following additional variables in the URL:

[cols=2]
|===

|_username |the automation user’s ID
|_secret |the user’s [.guihint]#Automation secret#
|===


Here is an example for opening a view in the JSON-Format with the automation
user `automation` and the secret as in the above image:

[{shell}]
----
{c-root} curl 'http://moni01.mycompany.net/mysite/check_mk/view.py?_username=automation&_secret=GLV@GYCAKINOLICMAFVP&view_name=svcproblems&output_format=json'
 [
  "service_state",
  "host",
  "service_description",
  "service_icons",
  "svc_plugin_output",
  "svc_state_age",
  "svc_check_age",
  "perfometer"
 ],
 [
  "CRIT",
  "stable",
  "Filesystem /",
  "menu pnp",
  "CRIT - 96.0% used (207.27 of 215.81 GB), (warn/crit at 80.00/90.00%), trend: +217.07 MB / 24 hours",
  "119 min",
  "30 sec",
  "96%"
 ],
 ...
----

If the script that opens the URL is running directly in the monitoring instance you can
read the user’s secret directly from the file system. This is not a security flaw,
rather it is specifically intended to be so. With this the automation script can be written without
containing the secret and also without requiring configurations data. To this end, simply select the file:
`~/var/check_mk/web/myuser/automation.secret`:

[{shell}]
----
{c-omd} cat var/check_mk/web/automation/automation.secret
GLV@GYCAKINOLICMAFVP
----

In the shell you can easily save this file’s content in a variable:

[{shell}]
----
{c-omd} SECRET=$(cat var/check_mk/web/automation/automation.secret)
{c-omd} echo "$SECRET"
GLV@GYCAKINOLICMAFVP
----

This also, for example, makes use of the `downtime` script, which can be
found in the {CMK} _Treasures_, and with which script-controlled planned downtimes
for hosts and services can be specified and deleted.
If the automation user is called `automation` as shown in our example,
only a single argument needs to be entered -- the hostname for which the downtime is to be defined:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime myhost123
----

You can learn about further options for this script in this online help:

[{shell}]
----
{c-omd} ~/share/doc/check_mk/treasures/downtime --help
----

== Automatic login via the URL

As we have seen with automation users using script contro you can open URLs arbitrarily
without logging in. In situations requiring a real browser this does not function,
as the login data for any contained links (e.g., images and iFrames) will not be forwarded.

The best example for this is the desire to hang a screen which continuously displays
a particular {CMK} dashboard on a wall.
The screen should be controlled by a computer that on starting automatically opens the browser,
logs itself in to {CMK}, and calls up the dashboard.

In order to realise this, the best method is to first create a special user.
The `guest` role is well-suited here because it has all read permissions,
but does not allow changes or interventions

The URL for an automatic login is constructed as follows:

. Begin with `http://mycmkserver/mysite/login.py?_origtarget=`
. Determine the the actual URL to be displayed (e.g., that of the dashboard) with your browser -- ideally so that only the right-most frame is displayed, without the side bar.
. Add this URL, leaving out out everything before `/mysite/...`
. Append both variables into the URL - `_username` and `_password` - in the following format: `&_username=myuser&_password=mysecret`
. Add a `&_login=1`

Here is an example of such a URL:

[{shell}]
----
http://mycmkserver/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1
----

Please note:

* Substitute your own values for the `mycmkserver`, `mysite`, `myuser` and `mypassword` fields in the example.
* If the special characters `&` or `%` are present in these values, or in the value for the `_origtarget` field, they must be substituted as follows: `&` by `%26` and `%` by `%25`.

Test this by logging out of {CMK} in your browser, and then pasting the contructed
URL in the browser’s address field. You should then arrive directly in the target
site -- without a login screen. You will nonetheless be logged in, and can directly access the links contained on the page.

You can also try the finished URL with `curl` on the command line.
If you have done everything correctly you will receive the result “`302 Found`” and a (“`The document
has moved...`”) redirection.

[{shell-raw}]
----
{c-omd}  curl 'http://localhost/mysite/check_mk/login.py?_origtarget=/mysite/check_mk/dashboard.py?name=mydashboard&_username=myuser&_password=mypassword&_login=1'
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>302 Found</title>
</head><body>
<h1>Found</h1>
<p>The document has moved here.</p>
</body></html>
----

If an error occurs you will receive the login mask’s HTML code
- this ends with the following code:

[{shell-raw}]
----
<!--
if (document.login._username) {    document.login._username.focus();
    document.login._username.select();
}
// -->
</script>
</body></html>
----

[#wato_permissions]
== WATO permissions

=== Importance of the user role for WATO

If you have a somewhat larger monitoring environment to manage, then you will
certainly want to involve colleagues in the the configuration,
and especially in the managing of hosts and services. So that you maintain control
over who can control what -- and in so doing not get in their way -- you can allocate
permissions based on folders in link:wato.html[WATO].

The first step is for your admin-colleagues to work with their own user-IDs based
on the `user` role.
In principle this role has a permission for WATO,
with a couple of important restrictions however:

*  Only changes to hosts, services, link:wato_rules.html[rules] and link:bi.html[BI-Aggregates] are allowed.
* Hosts, services and rules may only be managed in authorised folders.
* BI-Aggregates may only be managed in authorised BI-Packages.
* No action with a global impact is permiited.

If you haven’t yet shared folders or BI-Packages, members of the `user`
role can make no changes at all!
The sidebar’s WATO-element looks like this for normal operators:

image::wato_user_snapin_user.png[width=42%]

=== Enabling users to manage hosts

The permission for a user to create, edit and delete hosts is given
via link:wato_user.html#contact_groups[Contact groups]. The procedure is as follows:

. Add the user to a contact group.
. Specify one or more link:wato_hosts.html#folder[folders] for which the user should be authorised.
. Activate the [.guihint]#Permissions# attribute for this folder and there select the contact group.

The following example shows the attributes of a folder in which all of
the [.guihint]#Linux# contact group’s users are permitted to manage hosts.
Here the option to permit actions in subfolders is also activated.

image::wato_user_user_folder.png[]

Whether you wish to add the hosts to the contact groups automatically is up to you.
In this example the [.guihint]#Add these groups as contacts to all hosts in this folder# option
has not been selected, and the hosts will thus not be added to the [.guihint]#Linux# contact group.
They will therefore not be visible in the status overview for this [.guihint]#Linux# contact group
(as long as this is not handled by a rule). As can be seen, the visibility (and the
responsibility in monitoring) and the permission are thus separately controllable for WATO.

== Changing a password, password policies

=== Password security

Security has a high profile nowadays. Therefore in some organisations there are
generally guidelines for working with passwords. {CMK} offers a number of approaches
for enforcing such guidelines. One of these can be found in the global settings under
[.guihint]#User management > Password policy for local accounts#:

image::wato_user_password_policy.png[]

The first two settings should secure the password quality. There are altogether four
character groups (types) for the second setting:

* Lower case letters
* Upper case (capital) letters
* Numerics
* Special characters

Enter a *4* here, so that a password must contain at least one character from each of
the above-named groups. With a *2* it will at least be ensured, for example,
that a password doesn’t consist only of lower case letters. These settings will be
verified with every password change.

The third setting will force the user to change their password at regular intervals.
As soon as this time period has expired the next attempt to access a page will
direct the user to the following entry mask:

image::wato_user_forced_password_change.png[]

Only after changing their password will the user be permitted to continue. You can stipulate
a change from the initial (administrator-provided) password immediately at the user’s first login.
The [.guihint]#Enforce change: Change password at next login or access# option in the [.guihint]#Security#
section of the user's properties serves this purpose.

=== Login policies

==== Suspension following login failures

Further settings applicable to user logins can be found under [.guihint]#User management# in the global settings.
With the [.guihint]#Lock user accounts after N logon failures# you can lock a user’s account
following a predetermined number of login failures:

image::wato_user_login_failures.png[]

Unlocking can only be performed by a user with the `admin` role. Please note however,
that the administrator account itself can also be locked!
Should you be conclusively locked out, you can unlock your account via the command line.
As the instance user, also edit the `etc/htpasswd` file by removing the
exclamation mark from the affected user’s line.

[{shell}]
----
{c-omd} cat etc/htpasswd
cmkadmin:*!*.lwoHWmlCs.HTE
myuser:$1$771269$losX.vlIY34TTR6zwiG5s1
{c-omd} vim etc/htpasswd
{c-omd} cat etc/htpasswd
cmkadmin:.lwoHWmlCs.HTE
myuser:$1$771269$losX.vlIY34TTR6zwiG5s1
----

Following this procedure you will be able to log in again.

==== Automatic logout

A further setting ensures that a user whose GUI has been idle for long time
will be automatically logged out:

image::wato_user_login_idle_timeout.png[]

The timeout will be held up only by active use of the GUI.
An open view that just refreshes itself regularly doesn't satisfy this criterion.

==== Prevention of duplicate logins

The global [.guihint]#Limit login to single session at a time# option prevents a user logging in
to {CMK} from two browsers in parallel. This option is at the same time linked with
the timeout for automatically logging off idle users.
This also makes sense.
Assume you have forgotten to log yourself out before closing the browser at your workplace.
In such a situation, without a timeout it would not be possible for you to log in from home
if you were on call - because closing the browser or simply shutting down your computer
doesn't execute a logout! (You may be familiar with this from your homebanking...)

image::wato_user_limit_login.png[]

An attempt to log in a second time in parallel receives the following notice:

image::wato_user_another_session_is_active.png[width=60%]

In this situation a log in can only be completed if you first end the active session with
icon:button_sidebar_logout[], or wait for it to time out after the specified idle time.

[#change_passwd]
=== Changing a password using the command line

In an extreme case a password can be changed via the command line. This rescues
you if the `cmkadmin` password has been lost. It will naturally depend on
your being able to log in as a Linux user to the monitoring system and that you
can become a site user with `omd su mysite`.

The passwords are stored in the `~/etc/htpasswd` file.
Each line contains a login name followed by an encrypted password:

.~/etc/htpasswd
[{file}]
----
cmkadmin:pE27XD5FleOYc
myuser:$1$771269$losX.vlIY34TTR6zwiG5s1
----

The password change is performed using the `htpasswd` command that comes from th
Apache installation. This does *not* ask for the existing password. It is important
that you use `crypt()` as the encryption -- thus the `-d` option:

[{shell}]
----
{c-omd} htpasswd -d etc/htpasswd cmkadmin
New password: *geheim*
Re-type new password: *geheim*
Updating password for user cmkadmin
----

== Own user attributes

For user notifications, alongside the field for the email address there is a
[.guihint]#Pager# field available. If that is not sufficient for your needs and you want
to store more information to a user, with the [.guihint]#Custom attributes#
icon:button_custom_macros[] button you can create your own fields in which
values for each user can be individually entered.

Creating such a new field opens the following dialogue:

image::wato_user_custom_macro.png[]

As always, the ID cannot subsequently be changed, but the display name can be
changed at a later date if required.
[.guihint]#Topic# specifies to where the new field should be sorted in the user mask.
Furthermore, you can decide whether the field’s users will be permitted to edit the
field themselves (it will then appear in their personal settings), and whether the
value should be directly displayed in the user table.

*Important:* Only if the check box in [.guihint]#Make this variable available in notifications#
has been selected can this value also be used in notifications. Additionally this value
(e.g., link:cmc.html[CMC]) must be made known to the monitoring core in a variable (a so-called custom macro).

The custom variable’s name will be derived from that of the selected ID.
This name will be converted to upper case letters and a preceeding ‘`CONTACT_`’ will be added.
Thus from ‘`phone`’ the ‘`CONTACT_PHONE`’ custom variable will be generated.
Please note that when passing this value over environment variables a ‘`NOTIFY_`’ will
additionally be appended. For your own notification script the resulting variable will be
‘`NOTIFY_CONTACT_PHONE`’.

== Notifying users

In the link:notifications.html[article on notifications] we very comprehensively cover how {CMK} can
inform contacts of problems with hosts and services.
You may also occasionally wish to inform all users (even those who are not contacts) about
organisational matters that are in their interest -- for example, about maintenance affecting
the actual {CMK}-System.

To this end {CMK} offers a small built-in messaging system that functions
quite independently of the monitoring’s notifications.
The icon:button_notify_users[] button required for this purpose is located at the top of the
user management. With this you have the facility to compose a message to all (or some) of your users.

image::wato_user_notify_users.png[]

Here you can choose from four types of message:

[cols=2]
|===

|[.guihint]#Send an email# |With this you will only reach users for whom an email address has been configured.
|[.guihint]#Popup message in the GUI (shows up alert window)# |A popup window containing the message will open in the overview with the user's next page request.
|[.guihint]#Send hint to dashlet# |The message will be displayed in a link:dashboards.html#adddashlet[dashlet] of the types [.guihint]#User notifications#.
|[.guihint]#Send hint to message inbox (bottom of sidebar)# |The user will receive a icon:notify_users4[] numeral at the bottom of the side bar advising that a message is in their inbox - which the user can then open at will.
|===


With [.guihint]#automatic invalidation# not yet opened messages can simply be deleted once they are
no longer relevant.

== Further topics

{CMK} commands a number of additional variations for logging in.
These will be briefly discussed in this or an own article:

* Connection from the link:ldap.html[LDAP/Active Directory]
* Authentification with link:kerberos.html[Kerberos]
* Authentification in a construction using reverse proxy
* Authentification with HTTP Basic Authentication

[#files]
== Files and directories

The following summary shows which files and directories on the {CMK}-Server are associated
with user management. As always all information here is relative to the instance's directory.

[cols="45,~"]
|===
|File path |Function 

|etc/htpasswd |User passwords in Apache-`htpasswd`-Format.
|etc/auth.secret |This file contains a random secret for signing login cookies. The file should be the same in all instances in distributed environments. When you configure everything with WATO it will take care of this file automatically. If this data is changed all logins will immediately be void and users must log themselves in anew. The file is furnished with the `660` permission, as read access could enable a third party to falsify a login.
|etc/auth.serials |The serial numbers of the passwords by user. Every password change increments the serial number, thereby making all current sessions invalid. This ensures that a password alteration reliably forces a user to log out.
|etc/check_mk/multisite.d/wato/users.mk |Contains the users that have been defined using WATO. Here only the user data directly concerning the GUI is stored. Manual changes to these files will take effect immediately.
|etc/check_mk/conf.d/wato/contacts.mk |Contact information for users managed using WATO. Here all data relevant for the monitoring core’s configuration are stored. Only users who are also contacts are listed. Changes made manually here will subsequently require a `cmk -O` (Core reload) to be effective.
|var/check_mk/web |Every user who has signed in to the GUI at least once will have a directory here in which items such as self-created views and reports, their current side bar configuration, and many others, will be stored in small files with the `.mk` file extension. These files have the Python format.
|var/log/web.log |The user interface’s log data. Here error messages relating to permissions and LDAP connections can be found.
|===

